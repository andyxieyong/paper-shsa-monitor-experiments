#!/usr/bin/env python2.7
"""Run the pickle file generated by `bag_to_itoms.py`.

__date__ = 2019-02-28
__author__ = Denise Ratasich

"""

import argparse
from interval import interval
import pickle
import yaml

from model.itom import Itom, Itoms
from model.monitor import Monitor as SHSAMonitor


class Emulator(object):
    """Emulates monitor_node.py"""

    def __init__(self, model, variable, uncertainty=None):
        # hard-coded path to prolog shsa library -> use docker image!
        self.__monitor = SHSAMonitor(model, variable,
                                     librarypaths=["/python_ws/shsa-prolog/model"],
                                     recollect=False, uncertainty=uncertainty,
                                     buffer_size=1)
        self.__monitor.set_debug_callback(self.__debug_callback)

    @property
    def monitor(self):
        """Returns the monitor."""
        return self.__monitor

    def collect_inputs(self, data, period):
        """Collects itoms for monitor steps with given period
        (in same unit as timestamps of the itoms, e.g., nsec).

        Simulates the reception of itoms between two monitor steps.

        """
        # itoms: [(t_reception, itom),..]
        itoms = sorted(data['itoms'], key=lambda msg: msg[0])
        # collect itoms per period
        inputs = []  # all steps to execute
        step = []  # itoms for current monitor step
        for n, (tr, itom) in enumerate(itoms):
            # period over -> start next monitor step
            if tr > (len(inputs)+1)*period:
                inputs.append(((len(inputs)+1)*period, Itoms(step)))
                # reset for next step
                step = []
            step.append(itom)
        print "[run] number of steps: {}".format(len(inputs))
        return inputs

    def __debug_callback(self, inputs, outputs, error, failed):
        self.__debug = {
            'inputs': inputs,
            'outputs': {sidx: (o.t, o.v) for sidx, o in outputs},
            'error': error,
        }

    def __step(self, itoms):
        """Execute a monitor step."""
        failed = self.__monitor.monitor(itoms)
        # failed substitution to index
        try:
            failed_idx = self.__monitor.substitutions.index(failed)
        except ValueError as e:
            failed_idx = -1
        # add to debug output
        self.__debug['failed_idx'] = failed_idx
        return self.__debug

    def run(self, data):
        inputs = data['inputs']
        # run monitor for each Itoms in inputs
        outputs = []
        print "[run] ..."
        for n, (t, itoms) in enumerate(inputs):
            # execute monitor
            output = self.__step(itoms)
            output['tm'] = t
            outputs.append(output)
        print "[run] done."
        return outputs


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="""Run monitor with given sequence of itoms.""")
    parser.add_argument("picklefile", type=str,
                        help="""Data (pickle file) containing sequence of itoms.""")
    parser.add_argument("-m", "--model", type=str, default="../config/dmin.pl",
                        help="""Configuration file of the uncertainty model.""")
    parser.add_argument("-v", "--variable", type=str, default="dmin",
                        help="""Variable to monitor.""")
    parser.add_argument("-p", "--period", type=float, default=1e8,
                        help="""Monitoring period (time between two monitor calls).""")
    parser.add_argument("-u", "--uncertainty", type=str,
                        help="""Configuration file of the uncertainty model.""")
    args = parser.parse_args()

    with open(args.picklefile, 'rb') as f:
        data = pickle.load(f)

    # apply uncertainties in space and time if a config is available for that
    uncertainty = None
    if args.uncertainty:
        with open(args.uncertainty, 'r') as ymlfile:
            uncertainty = yaml.load(ymlfile)

    emulator = Emulator(args.model, args.variable, uncertainty=uncertainty)

    # order and split itoms for monitor steps
    data['inputs'] = emulator.collect_inputs(data, args.period)

    # run and save results
    result = {}
    result['outputs'] = emulator.run(data)
    result['substitutions'] = emulator.monitor.substitutions

    # keep info from fault injection if any
    try:
        result['manipulated'] = data['manipulated']
        result['faults'] = data['faults']
    except KeyError as e:
        pass

    result['itoms'] = data['itoms']

    with open("run_" + args.picklefile, 'wb') as f:
        pickle.dump(result, f, protocol=-1)
